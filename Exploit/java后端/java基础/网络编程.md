# .1 网络的相关概念

## 1.1 网络通信

1. 概念:两台设备之间通过网络实现数据传输
2. 网络通信:将数据通过网络从一台设备传输到另一台设备
3. java.net包下提供了一系列的类或接口，供程序员使用，完成网络通信

## 1.2 网络

1. 概念:两台或多台设备通过一定物理设备连接起来构成了网络
2. 根据网络的覆盖范围不同，对网络进行分类:
   - 局域网:覆盖范围最小,仅仅覆盖一个教室或一个机房
   - 城域网:覆盖范围较大，可以覆盖一个城市
   - 广域网:覆盖范围最大，可以覆盖全国,甚至全球,万维网是广域网的代表

## 1.3 ip地址

1. 概念:用于唯一标识网络中的每台计算机/主机
2. 查看ip地址: `ipconfig`
3. ip地址的表示形式: 点分十进制XX.XX.XX.XX
4. 每一个十进制数的范围:0~255
5. ip地址的组成=网络地址+主机地址，比如:192.168.16.69
6. iPv6是互联网工程任务组设计的用于替代IPv4的下一代IP协议，其地址数量号称可以为全世界的每一粒沙子编上一个地址。
7. 由于IPv4最大的问题在于网络地址资源有限，严重制约了互联网的应用和发展。IPv6的使用，不仅能解决网络地址资源数量的问题，而且也解决了多种接入设备连入互联网的障碍。

## 1.4 ipv4地址分类

特殊的：127.0.0.1表示本机地址

## 1.5 域名

1. www.baidu.com
2. 好处: 为了方便记忆，解决记`ip`的困难
3. 概念: 将`ip`地址映射成域名，这里怎么映射上——HTTP协议

## 1.6 端口号

1. 概念: ​**用于标识计算机上某个特定的网络程序**
2. 表示形式: 以整数形式，端口范围0~65535 [2个字节表示端口 0\~2^16-1]
3. 0\~1024已经被占用, 比如ssh 22, ftp 21, smtp 25 http 80
4. 常见的网络程序端口号
   - tomcat: 8080
   - mysql: 3306
   - oracle: 1521
   - sqlserver: 1433

## 1.7 网络通信协议

协议(tcp/ip)

TCP/IP (Transmission Control Protocol/Internet Protocol) 的简写,中文译名为传输控制协议/因特网互联协议,又叫网络通讯协议,这个协议是lnternet最基本的协议、Internet国际互联网络的基础,简单地说,就是由网络层的IP协议和传输层的TCP协议组成的。

## 1.8 TCP和UDP

TCP协议:传输控制协议

1. 使用TCP协议前,须先建立TCP连接,形成传输数据通道
2. 传输前,采用"三次握手"方式,是可靠的
3. TCP协议进行通信的两个应用进程: 客户端、服务端
4. 在连接中可进行大数据量的传输
5. 传输完毕，​**需释放已建立的连接, 效率低**

UDP协议:用户数据协议

1. 将数据、源、目的封装成数据包,不需要建立连接
2. 每个数据报的大小限制在64K内,不适合传输大量数据
3. 因无需连接,故是不可靠的
4. 发送数据结束时无需释放资源(因为不是面向连接的)，速度快

# 2 InetAddress类

## 2.1 相关方法

1. 获取本机InetAddress对象getLocalHost
2. 根据指定主机名/域名获取ip地址对象getByName
3. 获取InetAddress对象的主机名getHostName
4. 获取InetAddress对象的地址getHostAddress

## 21.2.2 应用案例

编写代码，获取计算机的主机名和IP地址相关API

```java
import java.net.InetAddress;
import java.net.UnknownHostException;

public class API_ {
    public static void main(String[] args) throws UnknownHostException {
        //1. 获取本机的InetAddress对象
        InetAddress localHost = InetAddress.getLocalHost();
        System.out.println(localHost);

        //2. 根据指定主机名获取InetAddress对象
        InetAddress host1 = InetAddress.getByName("DESKTOP-S4MP84S");
        System.out.println("host1=" + host1);

        //3. 根据域名返回InetAddress对象
        InetAddress host2 = InetAddress.getByName("www.baidu.com");
        System.out.println("host2=" + host2);

        //4. 通过InetAddress对象，获取对应的地址
        String hostAddress = host2.getHostAddress();
        System.out.println("host2对应的ip = " + hostAddress);

        //5. 通过InetAddress对象，获取对应的主机名/域名
        String hostName = host2.getHostName();
        System.out.println("host2对应的主机名/域名=" + hostName);
    }
}

```


# 3 Socket

## 3.1 基本介绍

1. 套接字(Socket)开发网络应用程序被广泛采用，以至于成为事实上的标准。
2. 通信的两端都要有Socket，是两台机器间通信的端点。
3. 网络通信其实就是Socket间的通信。
4. Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。
5. 一般主动发起通信的应用程序属客户端,等待通信请求的为服务端。

# 4 TCP网络通信编程

## 4.1 基本介绍

1. 基于客户端—服务端的网络通信
2. 底层使用的是TCP/IP协议
3. 应用场景举例: 客户端发送数据，服务端接受并显示控制台
4. 基于Socket的TCP编程

最后需要关闭socket，不然链接太多会出现问题。

## 4.2 应用案例1(使用字节流)

1. 编写一个服务器端,和一个客户端
2. 服务器端在9999端口监听
3. 客户端连接到服务器端,发送"hello, server"，然后退出
4. 服务器端接收到客户端发送的信息，输出，并退出

ServerSocket可以通过accept()返回多个Socket[多个客户端连接服务器的并发]

```java
import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class SocketTCP01Server {
    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(9999);
        System.out.println("服务端，在9999端口监听，等待连接..");
        
        Socket socket = serverSocket.accept();
        System.out.println("服务端socket =" + socket.getClass());
        
        InputStream inputStream = socket.getInputStream();
        byte[] buf = new byte[1024];
        int readLen = 0;
        while ((readLen = inputStream.read(buf)) != -1) {
            System.out.println(new String(buf, 0, readLen));
        }
        
        inputStream.close();
        socket.close();
        serverSocket.close();
    }
}
```

```java
import java.io.IOException;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.Socket;

public class SocketTCP01Client {
    public static void main(String[] args) throws IOException {
        Socket socket = new Socket(InetAddress.getLocalHost(), 9999);
        System.out.println("客户端socket返回=" + socket.getClass());
        
        OutputStream outputStream = socket.getOutputStream();
        outputStream.write("hello, server".getBytes());
        
        outputStream.close();
        socket.close();
        System.out.println("客户端退出.....");
    }
}
```

## 4.3 应用案例2(使用字节流)

1. 编写一个服务端,和一个客户端。
2. 服务器端在9999端口监听。
3. 客户端连接到服务端,发送"hello, server",并接收服务器端回发的"hello,client",再退出。
4. 服务器端接收到客户端发送的信息,输出，并发送"hello, client".再退出。

注意：设置结束标记。确保输出结束。

```java
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class SocketTCP02Server {
    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(9999);
        System.out.println("服务端，在9999端口监听，等待连接..");
        
        Socket socket = serverSocket.accept();
        System.out.println("服务端socket =" + socket.getClass());
        
        InputStream inputStream = socket.getInputStream();
        byte[] buf = new byte[1024];
        int readLen = 0;
        while ((readLen = inputStream.read(buf)) != -1) {
            System.out.println(new String(buf, 0, readLen));
        }
        
        OutputStream outputStream = socket.getOutputStream();
        outputStream.write("hello, client".getBytes());
        socket.shutdownOutput();
        
        outputStream.close();
        inputStream.close();
        socket.close();
        serverSocket.close();
    }
}
```

```java
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.Socket;

public class SocketTCP02Client {
    public static void main(String[] args) throws IOException {
        Socket socket = new Socket(InetAddress.getLocalHost(), 9999);
        System.out.println("客户端socket返回=" + socket.getClass());
        
        OutputStream outputStream = socket.getOutputStream();
        outputStream.write("hello, server".getBytes());
        socket.shutdownOutput();
        
        InputStream inputStream = socket.getInputStream();
        byte[] buf = new byte[1024];
        int readLen = 0;
        while ((readLen = inputStream.read(buf)) != -1) {
            System.out.println(new String(buf, 0, readLen));
        }
        
        inputStream.close();
        outputStream.close();
        socket.close();
        System.out.println("客户端退出.....");
    }
}
```

## 4.4 应用案例3(使用字符流)

1. 编写一个服务端,和一个客户端
2. 服务端在9999端口监听
3. 客户端连接到服务端，发送"hello, server",并接收服务端回发的"hello,client",再退出
4. 服务端接收到客户端发送的信息，输出，并发送"hello, client"，再退出

**这里结束标记也可以采用`writer.newLine();`，但是这要求对方读取必须使用`readLine()`。**

```java
import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class SocketTCP03Server {
    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(9999);
        System.out.println("服务端，在9999端口监听，等待连接..");
        
        Socket socket = serverSocket.accept();
        System.out.println("服务端socket =" + socket.getClass());
        
        InputStream inputStream = socket.getInputStream();
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
        String s = bufferedReader.readLine();
        System.out.println(s);
        
        OutputStream outputStream = socket.getOutputStream();
        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));
        bufferedWriter.write("hello client 字符流");
        bufferedWriter.newLine();
        bufferedWriter.flush();
        
        bufferedWriter.close();
        bufferedReader.close();
        socket.close();
        serverSocket.close();
    }
}
```

```java
import java.io.*;
import java.net.InetAddress;
import java.net.Socket;

public class SocketTCP03Client {
    public static void main(String[] args) throws IOException {
        Socket socket = new Socket(InetAddress.getLocalHost(), 9999);
        System.out.println("客户端socket返回=" + socket.getClass());
        
        OutputStream outputStream = socket.getOutputStream();
        BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));
        bufferedWriter.write("hello, server 字符流");
        bufferedWriter.newLine();
        bufferedWriter.flush();
        
        InputStream inputStream = socket.getInputStream();
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
        String s = bufferedReader.readLine();
        System.out.println(s);
        
        bufferedReader.close();
        bufferedWriter.close();
        socket.close();
        System.out.println("客户端退出.....");
    }
}
```

## 4.5 应用案例4

1. 编写一个服务端,和一个客户端
2. 服务器端在8888端口监听
3. 客户端连接到服务端,发送一张图片e:llqie.png
4. 服务器端接收到客户端发送的图片，保存到src下,发送"收到图片"再退出
5. 客户端接收到服务端发送的"收到图片"，再退出
6. 该程序要求使用StreamUtils.java,我们直接使用其中封装好的方法。

```java
import java.io.*;
import java.net.InetAddress;
import java.net.Socket;

public class TCPFileUploadClient {
    public static void main(String[] args) throws Exception {
        Socket socket = new Socket(InetAddress.getLocalHost(), 8888);
        
        String filePath = "e:\\abc.mp4";
        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(filePath));
        byte[] bytes = StreamUtils.streamToByteArray(bis);
        
        BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream());
        bos.write(bytes);
        bis.close();
        socket.shutdownOutput();
        
        InputStream inputStream = socket.getInputStream();
        String s = StreamUtils.streamToString(inputStream);
        System.out.println(s);
        
        inputStream.close();
        bos.close();
        socket.close();
    }
}
```

```java
import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class TCPFileUploadServer {
    public static void main(String[] args) throws Exception {
        ServerSocket serverSocket = new ServerSocket(8888);
        System.out.println("服务端在8888端口监听....");
        
        Socket socket = serverSocket.accept();
        BufferedInputStream bis = new BufferedInputStream(socket.getInputStream());
        byte[] bytes = StreamUtils.streamToByteArray(bis);
        
        String destFilePath = "src\\abc.mp4";
        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFilePath));
        bos.write(bytes);
        bos.close();
        
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));
        writer.write("收到图片");
        writer.flush();
        socket.shutdownOutput();
        
        writer.close();
        bis.close();
        socket.close();
        serverSocket.close();
    }
}
```

## 4.6 netstat指令

1. `netstat -an`可以查看当前主机网络情况，包括项口监听情况和网络连接情况
2. `netstat -an | more`可以分页显示
3. `netstat -anb`（在管理员状态下运行）可以查看是哪些应用监听该端口。
4. 外部地址就是连接该本地地址和端口号的客户端的IP和端口号。

说明:
(1) Listening表示某个端口在监听 Established表示连接已经建立
(2)如果有一个外部程序(客户端)连接到该端口，就会显示一条连接信息

## 4.7 TCP网络通讯

1. 当客户端连接到服务端后，实际上客户端也是通过一个端口和服务端进行通讯的，这个端口是TCP/IP来分配的，是不确定的，是随机的。（**客户端的端口**）
2. 程序验证+netstat

# 5 UDP网络通信编程

## 5.1 基本介绍

1. 类`DatagramSocket`和`DatagramPacket`[数据包/数据报]实现了基于UDP协议网络程序。
2. UDP数据报通过数据报套接字`DatagramSocket`发送和接收，系统不保证UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。
3. `DatagramPacket`对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。
4. UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接

## 5.2 基本流程

1. 核心的两个类/对象DatagramSocket与DatagramPacket
2. 建立发送端，接收端(没有服务端和客户端概念)
3. 发送数据前,建立数据包/报DatagramPacket对象
4. 调用DatagramSocket的发送、接收方法
5. 关闭DatagramSocket

## 5.3 应用案例

1. 编写一个接收端A,和一个发送端B
2. 接收端A在9999端口等待接收数据(receive)
3. 发送端B向接收端A发送数据"hello，明天吃火锅~"
4. 接收端A接收到发送端B发送的数据，回复"好的,明天见"再退出
5. 发送端接收回复的数据,再退出

```java
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;

public class UDPReceiverA {
    public static void main(String[] args) throws IOException {
        DatagramSocket socket = new DatagramSocket(9999);
        byte[] buf = new byte[1024];
        DatagramPacket packet = new DatagramPacket(buf, buf.length);
        
        System.out.println("接收端A等待接收数据..");
        socket.receive(packet);
        
        int length = packet.getLength();
        byte[] data = packet.getData();
        String s = new String(data, 0, length);
        System.out.println(s);
        
        data = "好的, 明天见".getBytes();
        packet = new DatagramPacket(data, data.length, InetAddress.getByName("192.168.12.1"), 9998);
        socket.send(packet);
        
        socket.close();
        System.out.println("A端退出...");
    }
}
```

```java
import java.io.IOException;
import java.net.*;

public class UDPSenderB {
    public static void main(String[] args) throws IOException {
        DatagramSocket socket = new DatagramSocket(9998);
        
        byte[] data = "hello 明天吃火锅~".getBytes();
        DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName("192.168.12.1"), 9999);
        socket.send(packet);
        
        byte[] buf = new byte[1024];
        packet = new DatagramPacket(buf, buf.length);
        socket.receive(packet);
        
        int length = packet.getLength();
        data = packet.getData();
        String s = new String(data, 0, length);
        System.out.println(s);
        
        socket.close();
        System.out.println("B端退出");
    }
}
```


# 6. 网络编程进阶技巧

## 6.1 多线程服务器
通过多线程处理多个客户端请求，避免阻塞主线程：
```java
// 服务端代码示例
public class MultiThreadServer {
    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(8080);
        while (true) {
            Socket clientSocket = serverSocket.accept();
            new Thread(() -> handleClient(clientSocket)).start();
        }
    }

    private static void handleClient(Socket socket) {
        try (InputStream is = socket.getInputStream();
             OutputStream os = socket.getOutputStream()) {
            // 处理客户端请求
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

## 6.2 NIO非阻塞编程
使用Java NIO实现高性能网络通信：
```java
Selector selector = Selector.open();
ServerSocketChannel serverChannel = ServerSocketChannel.open();
serverChannel.bind(new InetSocketAddress(8080));
serverChannel.configureBlocking(false);
serverChannel.register(selector, SelectionKey.OP_ACCEPT);

while (true) {
    selector.select();
    Set<SelectionKey> keys = selector.selectedKeys();
    Iterator<SelectionKey> iter = keys.iterator();
    while (iter.hasNext()) {
        SelectionKey key = iter.next();
        if (key.isAcceptable()) {
            // 处理新连接
        } else if (key.isReadable()) {
            // 处理读事件
        }
        iter.remove();
    }
}
```

## 6.3 协议设计规范
1. **固定长度协议**：每个消息固定字节长度
2. **分隔符协议**：用特殊字符（如`\n`）分隔消息
3. **TLV协议**：Type-Length-Value结构


# 7 常见问题解决方案

## 7.1 粘包/拆包问题
解决方案：
1. 使用消息头声明消息长度
2. 添加消息边界分隔符
3. 使用固定长度消息

## 7.2 连接超时处理
```java
Socket socket = new Socket();
socket.connect(new InetSocketAddress(host, port), 5000); // 5秒超时
socket.setSoTimeout(3000); // 读写超时3秒
```

## 7.3 资源释放规范
推荐使用try-with-resources确保资源关闭：
```java
try (Socket socket = new Socket(host, port);
     OutputStream out = socket.getOutputStream()) {
    // 使用socket
} // 自动关闭
```


# 8 性能优化建议

1. **连接池技术**：复用TCP连接
2. **零拷贝技术**：使用FileChannel.transferTo()
3. **缓冲区优化**：根据业务调整缓冲区大小
4. **异步IO**：使用Java AIO或Netty框架



# 9 网络安全基础

## 9.1 SSL/TLS加密
```java
SSLServerSocketFactory sslFactory = 
    (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
SSLServerSocket serverSocket = 
    (SSLServerSocket) sslFactory.createServerSocket(8443);
```

## 9.2 常见攻击防护
1. **DDoS防护**：限流机制
2. **中间人攻击**：证书验证
3. **注入攻击**：输入校验



# 10 调试与监控

## 10.1 网络抓包工具
1. Wireshark
2. tcpdump
3. Fiddler

## 10.2 Java诊断命令
```bash
netstat -ano | find "8080"  # Windows查看端口占用
lsof -i :8080               # Linux/Mac查看端口
jstack <pid>                # 查看Java线程栈
```