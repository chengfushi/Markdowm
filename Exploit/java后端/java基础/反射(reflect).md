# 1. 一个需求引出反射

1. 根据配置文件 re.properties 指定信息,创建Cat对象并调用方法hi

   ```properties
   classfullpath = com.hspedu.Cat
   method = hi
```

2. 这样的需求在学习框架时特别多，即通过外部文件配置，在不修改源码情况下。来控制程序，也符合设计模式的ocp原则(开闭原则:不修改源码，扩容功能)。

```java
import com.hspedu.Cat;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Properties;

/**
 • 反射问题的引入
 */
@SuppressWarnings({"all"})
public class ReflectionQuestion {
    public static void main(String[] args) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {

        //根据配置文件 re.properties 指定信息, 创建Cat对象并调用方法hi
        //传统的方式 new 对象 -》 调用方法
//        Cat cat = new Cat();
//        cat.hi(); ===> cat.cry() 修改源码.

        //我们尝试做一做 -> 明白反射

        //1. 使用Properties 类, 可以读写配置文件
        Properties properties = new Properties();
        properties.load(new FileInputStream("src\\re.properties"));
        String classfullpath = properties.get("classfullpath").toString();//"com.hspedu.Cat"
        String methodName = properties.get("method").toString();//"hi"
        System.out.println("classfullpath=" + classfullpath);
        System.out.println("method=" + methodName);

        //2. 创建对象 , 传统的方法，行不通 =》 反射机制
        //new classfullpath(); // classfullpath 这是一个字符串，而正规应该new 类名()

        //3. 使用反射机制解决
        //(1) 加载类, 返回Class类型的对象cls
        Class cls = Class.forName(classfullpath);
        //(2) 通过 cls 得到你加载的类 com.hspedu.Cat 的对象实例
        Object o = cls.newInstance();
        System.out.println("o的运行类型=" + o.getClass()); //运行类型
        //(3) 通过 cls 得到你加载的类 com.hspedu.Cat 的 methodName"hi"  的方法对象
        //    即：在反射中，可以把方法视为对象（万物皆对象）
        Method method1 = cls.getMethod(methodName);
        //(4) 通过method1 调用方法: 即通过方法对象来实现调用方法
        System.out.println("=============================");
        method1.invoke(o); //传统方法 对象.方法() , 反射机制 方法.invoke(对象)
    }
}
```

# 2. 反射机制

## 2.1 Java Reflection

1. 反射机制允许程序在执行期借助于 `Reflection API` 取得任何类的内部信息(比如成员变量，构造器，成员方法等等)，并能操作对象的属性及方法。反射在设计模式和框架底层都会用到。

2. 加载完类之后，在堆中就产生了一个Class类型的对象( 一个类只有一个Class对象)，这个对象包含了类的完整结构信息。通过这个对象得到类的结构。这个Class对象就像一面镜子,透过这个镜子看到类的结构,所以,形象的称之为：反射。

类比：

p对象 ---> 类型Person类

Class对象cls ---> 类型Class类

## 2.2 Java 反射机制可以完成

1. 在运行时判断任意一个对象所属的类

2. 在运行时构造任意一个类的对象

3. 在运行时得到任意一个类所具有的成员变量和方法

4. 在运行时调用任意一个对象的成员变量和方法

5. 生成动态代理

## 2.3 反射相关的主要类

1. java.lang.Class:代表一个类，Class对象表示某个类加载后在堆中的对
2. java.lang.reflect.Method:代表类的方法, Method对象表示某个类的方法
3. java.lang.reflect.Field:代表类的成员变量,Field对象表示某个类的成员变量
4. java.lang.reflect.Constructor:代表类的构造方法,Constructor对象表示
构造器

这些类在java.lang.reflection

```java
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Properties;

public class Reflection01 {

    public static void main(String[] args) throws Exception {

        //1. 使用Properties 类, 可以读写配置文件
        Properties properties = new Properties();
        properties.load(new FileInputStream("src\\re.properties"));
        String classfullpath = properties.get("classfullpath").toString();//"com.hspedu.Cat"
        String methodName = properties.get("method").toString();//"hi"

        //2. 使用反射机制解决
        //(1) 加载类, 返回Class类型的对象cls
        Class cls = Class.forName(classfullpath);
        //(2) 通过 cls 得到你加载的类 com.hspedu.Cat 的对象实例
        Object o = cls.newInstance();
        System.out.println("o的运行类型=" + o.getClass()); //运行类型
        //(3) 通过 cls 得到你加载的类 com.hspedu.Cat 的 methodName"hi"  的方法对象
        //    即：在反射中，可以把方法视为对象（万物皆对象）
        Method method1 = cls.getMethod(methodName);
        //(4) 通过method1 调用方法: 即通过方法对象来实现调用方法
        System.out.println("=============================");
        method1.invoke(o); //传统方法 对象.方法() , 反射机制 方法.invoke(对象)

        // java.lang.reflect.Field: 代表类的成员变量, Field对象表示某个类的成员变量
        // getField不能得到私有的属性
        Field nameField = cls.getField("age"); //
        System.out.println(nameField.get(o)); // 传统写法 对象.成员变量 , 反射: 成员变量对象.get(对象)

        //java.lang.reflect.Constructor: 代表类的构造方法, Constructor对象表示构造器
        //()中可以指定构造器参数类型, 返回无参构造器
        Constructor constructor = cls.getConstructor();
        System.out.println(constructor);//Cat()


        Constructor constructor2 = cls.getConstructor(String.class); //这里老师传入的 String.class 就是String类的Class对象
        System.out.println(constructor2);//Cat(String name)
    }
}
```

## 2.4 反射优点和缺点

1. 优点:可以动态的创建和使用对象(也是框架底层核心),使用灵活,没有反射机制,框架技术就失去底层支撑。
2. 缺点:使用反射基本是解释执行,对执行速度有影响.

## 2.5 反射调用优化-关闭访问检查

1. Method 和 Field、Constructor对象都有 setAccessible() 方法
2. setAccessible作用是启动和禁用访问安全检查的开关
3. 参数值为true表示反射的对象在使用时取消访问检查，提高反射的效率。参数值为false则表示反射的对象执行访问检查。

```java
import java.io.FileInputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 • 测试反射调用的性能，和优化方案
 */
public class Reflection02 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        m1();
        m2();
        m3();
    }

    //传统方法来调用hi
    public static void m1() {

        Cat cat = new Cat();
        long start = System.currentTimeMillis();
        for (int i = 0; i < 90; i++) {
            cat.hi();
        }
        long end = System.currentTimeMillis();
        System.out.println("m1() 耗时=" + (end - start));
    }

    //反射机制调用方法hi
    public static void m2() throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {

        Class cls = Class.forName("com.hspedu.Cat");
        Object o = cls.newInstance();
        Method hi = cls.getMethod("hi");
        long start = System.currentTimeMillis();
        for (int i = 0; i < 900000000; i++) {
            hi.invoke(o);//反射调用方法
        }
        long end = System.currentTimeMillis();
        System.out.println("m2() 耗时=" + (end - start));
    }

    //反射调用优化 + 关闭访问检查

    public static void m3() throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {

        Class cls = Class.forName("com.hspedu.Cat");
        Object o = cls.newInstance();
        Method hi = cls.getMethod("hi");
        hi.setAccessible(true);//在反射调用方法时，取消访问检查
        long start = System.currentTimeMillis();
        for (int i = 0; i < 900000000; i++) {
            hi.invoke(o);//反射调用方法
        }
        long end = System.currentTimeMillis();
        System.out.println("m3() 耗时=" + (end - start));
    }
}
```

# 3. Class 类

## 3.1 基本介绍

1. Class也是类，因此也继承Object类[类图]
2. Class类对象不是new出来的，而是系统创建的[演示]
3. 对于某个类的Class类对象,在内存中只有一份，因为类只加载一次[演示]
4. 每个类的实例都会记得自己是由哪个Class 实例所生成
5. 通过Class对象可以完整地得到一个类的完整结构,通过一系列API
6. Class对象是存放在堆的
7. 类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据(包括方法代码, 变量名，方法名，访问权限等等)

```java
import java.util.ArrayList;

/**
 • 对Class类特点的梳理
 */
public class Class01 {
    public static void main(String[] args) throws ClassNotFoundException {
        //看看Class类图
        //1. Class也是类，因此也继承Object类
        //Class
        //2. Class类对象不是new出来的，而是系统创建的
        //(1) 传统new对象
        /*  ClassLoader类
            public Class<?> loadClass(String name) throws ClassNotFoundException {
                return loadClass(name, false);
            }
         */
        //Cat cat = new Cat();
        //(2) 反射方式, 刚才老师没有debug到 ClassLoader类的 loadClass, 原因是，我没有注销Cat cat = new Cat(); 而类只会加载一次，刚刚加载过下面就不会再次加载
        /*
            ClassLoader类, 仍然是通过 ClassLoader类加载Cat类的 Class对象
            public Class<?> loadClass(String name) throws ClassNotFoundException {
                return loadClass(name, false);
            }
         */
        Class cls1 = Class.forName("com.hspedu.Cat");

        //3. 对于某个类的Class类对象，在内存中只有一份，因为类只加载一次!!!!!!!!!!
        Class cls2 = Class.forName("com.hspedu.Cat");
        System.out.println(cls1.hashCode());
        System.out.println(cls2.hashCode()); // 相等
        Class cls3 = Class.forName("com.hspedu.Dog");
        System.out.println(cls3.hashCode());
    }
}
```

## 3.2 Class 类的常用方法

```java
import java.lang.reflect.Field;

/**
 • 演示Class类的常用方法
 */
public class Class02 {
    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchFieldException {

        String classAllPath = "com.hspedu.Car";
        //1 . 获取到Car类 对应的 Class对象
        //<?> 表示不确定的Java类型
        Class<?> cls = Class.forName(classAllPath);
        //2. 输出cls
        System.out.println(cls); //显示cls对象, 是哪个类的Class对象 com.hspedu.Car
        System.out.println(cls.getClass());//输出cls运行类型 java.lang.Class
        //3. 得到包名
        System.out.println(cls.getPackage().getName());//包名 com.hspedu
        //4. 得到全类名
        System.out.println(cls.getName()); // com.hspedu.Car
        //5. 通过cls创建对象实例
        Car car = (Car) cls.newInstance();
        System.out.println(car);//car.toString()
        //6. 通过反射获取属性 brand
        Field brand = cls.getField("brand");
        System.out.println(brand.get(car));//宝马
        //7. 通过反射给属性赋值
        brand.set(car, "奔驰");
        System.out.println(brand.get(car));//奔驰
        //8 我希望大家可以得到所有的属性(字段)
        System.out.println("=======所有的字段属性====");
        Field[] fields = cls.getFields();
        for (Field f : fields) {
            System.out.println(f.getName());//名称
        }
    }
}
```

## 3.3 获取Class 类对象

1.前提：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法 `forName()` 获取，可能抛出 `ClassNotFoundException`，实例:

```java
Class cls1 = Class.forName("java.lang.Cat");
```

应用场景：多用于配置文件,读取类全路径,加载类.

2.前提：若已知具体的类，通过类的 class 获取，该方式最为安全可靠，程序性能最高，实例：

```java
Class cls2 = Cat.class
```

应用场景:多用于参数传递，比如通过反射得到对应构造器对象.

3.前提:已知某个类的实例，调用该实例的 getClass() 方法获取Class对象，实例:

```java
Class clazz =对象.getClass();//运行类型
```

应用场景:通过创建好的对象，获取Class对象.

4.其他方式

```java
ClassLoader cls =对象.getClass(.getClassLoaderO;
Class clazz4 = cl.loadClass("类的全类名");
```

5.基本数据 (int, char,boolean.float,double,byte,long,short) 按如下方式得到Class类对象：

```java
Class cls =基本数据类型.class
```

6.基本数据类型对应的包装类,可以通过.TYPE得到Class类对象：

```java
Class cls = 包装类.TYPE
```

```java

/**
 • 演示得到Class对象的各种方式(6)
 */
public class GetClass_ {
    public static void main(String[] args) throws ClassNotFoundException {

        //1. Class.forName
        String classAllPath = "com.hspedu.Car"; //通过读取配置文件获取
        Class<?> cls1 = Class.forName(classAllPath);
        System.out.println(cls1);

        //2. 类名.class , 应用场景: 用于参数传递（例如前面通过反射得到构造器对象 传入参数就是 类名.class）
        Class cls2 = Car.class;
        System.out.println(cls2);

        //3. 对象.getClass(), 应用场景，有对象实例
        Car car = new Car();
        Class cls3 = car.getClass();
        System.out.println(cls3);

        //4. 通过类加载器【有4种类加载器】来获取到类的Class对象
        //(1)先得到类加载器 car
        ClassLoader classLoader = car.getClass().getClassLoader();
        //(2)通过类加载器得到Class对象
        Class cls4 = classLoader.loadClass(classAllPath);
        System.out.println(cls4);

        //cls1 , cls2 , cls3 , cls4 其实是同一个对象，因为一个类只能有一个class对象
        System.out.println(cls1.hashCode());
        System.out.println(cls2.hashCode());
        System.out.println(cls3.hashCode());
        System.out.println(cls4.hashCode());

        //5. 基本数据(int, char,boolean,float,double,byte,long,short) 按如下方式得到Class类对象
        Class<Integer> integerClass = int.class;
        Class<Character> characterClass = char.class;
        Class<Boolean> booleanClass = boolean.class;
        System.out.println(integerClass);//int

        //6. 基本数据类型对应的包装类，可以通过 .TYPE 得到Class类对象
        Class<Integer> type1 = Integer.TYPE;
        Class<Character> type2 = Character.TYPE; //其它包装类BOOLEAN, DOUBLE, LONG,BYTE类似
        System.out.println(type1);

        System.out.println(integerClass.hashCode());// 是同一个
        System.out.println(type1.hashCode());// 是同一个
    }
}
```

# 4. 哪些类型有Class 对象

## 4.1 如下类型有Class 对象

1. 外部类，成员内部类，静态内部类,局部内部类，匿名内部类
2. interface:接口
3. 数组
4. enum:枚举
5. annotation:注解
6. 基本数据类型
7. void

```java
import java.io.Serializable;

/**
 • 演示哪些类型有Class对象
 */
public class AllTypeClass {
    public static void main(String[] args) {

        Class<String> cls1 = String.class;//外部类
        Class<Serializable> cls2 = Serializable.class;//接口
        Class<Integer[]> cls3 = Integer[].class;//数组
        Class<float[][]> cls4 = float[][].class;//二维数组
        Class<Deprecated> cls5 = Deprecated.class;//注解
        Class<Thread.State> cls6 = Thread.State.class;//枚举
        Class<Long> cls7 = long.class;//基本数据类型
        Class<Void> cls8 = void.class;//void数据类型
        Class<Class> cls9 = Class.class;//

        System.out.println(cls1);
        System.out.println(cls2);
        System.out.println(cls3);
        System.out.println(cls4);
        System.out.println(cls5);
        System.out.println(cls6);
        System.out.println(cls7);
        System.out.println(cls8);
        System.out.println(cls9);
    }
}
```

# 5. 类加载

## 5.1 基本说明

反射机制是java实现动态语言的关键，也就是通过**反射实现类动态加载**。

1. 静态加载:编译时加载相关的类，如果没有则报错，依赖性太强。
2. 动态加载:运行时加载需要的类，如果运行时不用该类，即使不存在该类，也不报错，降低了依赖性。

## 5.2 类加载时机

1. 当创建对象时(new) //静态加载
2. 当子类被加载时，父类也加载 //静态加载
3. 调用类中的静态成员时 //静态加载
4. 通过反射 //动态加载

Class.forName("com.test.Cat");

## 5.3 类加载各阶段完成任务

1. 加载阶段
   JVM在该阶段的主要目的是将字节码从不同的数据源(可能是class文件、也可能是jar包，甚至网络）转化为**二进制字节流加载到内存中**，并**生成一个代表该类的java.lang.Class对象**。

2. 连接阶段-验证
   • 目的是为了确保 Class文件的字节流中包含的信息符合当前虚拟机的要求
   • 包括:文件格式验证(是否以魔数oxcafebabe开头)、元数据验证、字节码验证和符号引用验证
   • 可以使用 `-Xverify:none` 参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间

3. 连接阶段-准备
   JVM会在该阶段对静态变量，分配内存并默认初始化（对应数据类型的默认初始值，如0、OL、null、false等)

```java
public class ClassLoad02 {
    public static void main(String[] args) {
    }
}
class A {
    public int n1 = 10;  // 实例属性，准备阶段不处理
    public static int n2 = 20; // 静态变量，准备阶段初始化为0
    public static final int n3 = 30; // 常量，准备阶段直接赋值为30
}
```

4. 连接阶段-解析
   虚拟机将常量池内的**符号引用**替换为**直接引用**的过程

5. Initialization初始化
   • 执行类中定义的Java程序代码
   • 执行<clinit>()方法（由编译器自动收集所有静态变量赋值和静态代码块合并生成）
   • 虚拟机保证<clinit>()方法在多线程环境中被正确加锁同步



# 6. 通过反射获取类的结构信息

## 6.1 获取类信息

```java
// 获取全类名
String className = cls.getName(); 

// 获取简单类名
String simpleName = cls.getSimpleName();

// 获取包信息
Package pkg = cls.getPackage();

// 获取父类Class对象
Class superCls = cls.getSuperclass();

// 获取实现的接口
Class[] interfaces = cls.getInterfaces();

// 获取注解信息
Annotation[] annotations = cls.getAnnotations();
```

## 6.2 获取字段信息

```java
// 获取所有public字段(包括父类)
Field[] fields = cls.getFields();

// 获取本类所有字段(包括private)
Field[] declaredFields = cls.getDeclaredFields();

// 获取指定public字段
Field field = cls.getField("fieldName");

// 获取字段修饰符
int modifiers = field.getModifiers();

// 获取字段类型
Class fieldType = field.getType();

// 获取字段名
String fieldName = field.getName();
```

## 6.3 获取方法信息

```java
// 获取所有public方法(包括父类)
Method[] methods = cls.getMethods();

// 获取本类所有方法(包括private)
Method[] declaredMethods = cls.getDeclaredMethods();

// 获取方法修饰符
int modifiers = method.getModifiers();

// 获取返回类型
Class returnType = method.getReturnType();

// 获取参数类型
Class[] paramTypes = method.getParameterTypes();

// 获取异常类型 
Class[] exceptionTypes = method.getExceptionTypes();
```

## 6.4 获取构造器信息

```java
// 获取所有public构造器
Constructor[] constructors = cls.getConstructors();

// 获取本类所有构造器(包括private)
Constructor[] declaredConstructors = cls.getDeclaredConstructors();

// 获取构造器参数类型
Class[] paramTypes = constructor.getParameterTypes();
```

# 7. 通过反射创建对象

## 7.1 创建对象方式

1. 调用无参构造器

```java
Class cls = Class.forName("com.example.User");
Object obj = cls.newInstance();
```

2. 调用有参构造器

```java
// 获取指定参数类型的构造器
Constructor constructor = cls.getConstructor(String.class, int.class);

// 创建对象实例
Object obj = constructor.newInstance("张三", 25);
```

3. 访问私有构造器

```java
// 获取私有构造器
Constructor privateConstructor = cls.getDeclaredConstructor(String.class);

// 设置可访问
privateConstructor.setAccessible(true);

// 创建实例
Object obj = privateConstructor.newInstance("私有构造");
```

# 8. 通过反射访问类成员

## 8.1 访问字段

```java
// 获取字段对象
Field field = cls.getDeclaredField("name");

// 设置可访问(对private字段)
field.setAccessible(true);

// 获取字段值
Object value = field.get(obj);

// 设置字段值
field.set(obj, "新值");
```

## 8.2 调用方法

```java
// 获取方法对象
Method method = cls.getDeclaredMethod("methodName", paramTypes);

// 设置可访问(对private方法)
method.setAccessible(true);

// 调用方法
Object result = method.invoke(obj, args);

// 调用静态方法
method.invoke(null, args);
```