[toc]
Java中的异常机制用于处理程序运行时的错误和意外情况。异常分为检查型异常（Checked Exceptions）、非检查型异常（Unchecked Exceptions）以及错误（Errors）。以下是它们的分类、常见异常及对应场景的详细说明：

---

### **一、检查型异常（Checked Exceptions）**

**特点**：

- 编译时强制处理（必须捕获或声明抛出 `throws`）。
- 通常是外部因素导致的可恢复问题（如文件不存在、网络中断）。

#### **常见异常及场景**：

1. **`IOException`**
    
    - **前因**：输入/输出操作失败。
    - **场景**：读写文件、网络通信时发生的错误。
    - **子类**：
        - `FileNotFoundException`：尝试打开不存在的文件。
        - `EOFException`：读取文件时意外到达文件末尾。
    
    ```
    try (FileReader fr = new FileReader("file.txt")) {
        // 读取文件
    } catch (FileNotFoundException e) {
        System.out.println("文件未找到: " + e.getMessage());
    } catch (IOException e) {
        e.printStackTrace();
    }
    ```
    
2. **`SQLException`**
    
    - **前因**：数据库操作失败（如连接断开、查询语法错误）。
    - **场景**：执行JDBC操作时发生的错误。

---

### **二、非检查型异常（Unchecked Exceptions）**

**特点**：

- 无需显式处理（由程序逻辑错误引起，不应通过异常处理掩盖）。
- 继承自 `RuntimeException`。

#### **常见异常及场景**：

1. **`NullPointerException`**
    
    - **前因**：调用了`null`对象的方法或访问属性。
    - **场景**：未初始化的对象被使用。
    
    ```
    String str = null;
    System.out.println(str.length()); // 抛出 NullPointerException
    ```
    
2. **`ArrayIndexOutOfBoundsException`**
    
    - **前因**：访问数组的非法索引（负数或超过数组长度）。
    - **场景**：循环遍历数组时索引越界。
    
    ```
    int[] arr = {1, 2};
    System.out.println(arr[3]); // 抛出 ArrayIndexOutOfBoundsException
    ```
    
3. **`IllegalArgumentException`**
    
    - **前因**：方法接收到非法参数。
    - **场景**：参数校验失败时主动抛出。
    
    ```
    public void setAge(int age) {
        if (age < 0) {
            throw new IllegalArgumentException("年龄不能为负");
        }
        this.age = age;
    }
    ```
    
4. **`ClassCastException`**
    
    - **前因**：对象强制转换到不兼容的类型。
    - **场景**：未经类型检查就强制转换。
    
    ```
    Object obj = "Hello";
    Integer num = (Integer) obj; // 抛出 ClassCastException
    ```
    

---

### **三、错误（Errors）**

**特点**：

- 严重问题（如JVM崩溃、资源耗尽）。
- 通常是程序无法处理的系统级错误，继承自 `Error`。

#### **常见错误及场景**：

1. **`OutOfMemoryError`**
    
    - **前因**：堆内存不足以创建新对象。
    - **场景**：大规模数据处理或内存泄漏时。
    
    ```java
    // 模拟内存溢出
    List<Object> list = new ArrayList<>();
    while (true) {
        list.add(new Object());
    }
    ```
    
2. **`StackOverflowError`**
    
    - **前因**：调用栈深度超过限制（如无限递归）。
    - **场景**：递归调用缺少终止条件。
    
    ```
    public static void recursiveCall() {
        recursiveCall(); // 无限递归导致 StackOverflowError
    }
    ```
    

---

### **四、异常处理最佳实践**

1. **避免吞没异常**：  
    不要捕获异常后不做任何处理（如`catch`块为空），这会隐藏问题。
    
2. **优先使用 try-with-resources**（Java 7+）：  
    自动关闭资源（如文件流），避免资源泄漏。
    
    ```
    try (BufferedReader br = new BufferedReader(new FileReader("file.txt"))) {
        String line = br.readLine();
    } catch (IOException e) {
        e.printStackTrace();
    }
    ```
    
3. **自定义异常**：  
    通过继承 `Exception` 或 `RuntimeException` 创建业务相关的异常。
    
    ```
    public class ValidationException extends RuntimeException {
        public ValidationException(String message) {
            super(message);
        }
    }
    ```
    
4. **合理分组异常**（Java 7+）：  
    减少重复代码，处理多个相似异常。
    
    ```
    try {
        // 可能抛出多种异常
    } catch (FileNotFoundException | SQLException e) {
        System.out.println("文件或数据库错误: " + e.getMessage());
    }
    ```
    

---

### **总结**

Java的异常机制帮助开发者区分可恢复错误（检查型异常）和程序逻辑错误（非检查型异常）。合理处理异常能提高程序的健壮性，而错误（Errors）通常表示不可恢复的系统级问题。通过遵循最佳实践，可以编写清晰、安全的代码。