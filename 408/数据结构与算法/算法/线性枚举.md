# 1.求最大值
比如求一个线性表中的最大值，可以先设定一个最大值，把它初始化为一个非常小的数，然后遍历给定的线性表，将其中的每个元素和目前的最大值比较，如果比它大，则更新这个最大值；
如果比它小，就不做任何处理。遍历完毕返回最大值就是我们要求的解了。写成伪代码如下：
>最大值 = 非常小的数
>for 当前元素 in 给定的线性表
>	if 当前元素 > 最大值
>		最大值 = 当前元素
>返回最大值
# 2.求和
求一个线性表中元素的和，可以先设定一个求和的值，初始化为0，然后遍历给定的线性表，
将当前元素的值累加到求和变量上，最后返回求和变量的值，就是我们要求的解了。
>求和=0
>for 当前元素 in 给定的线性表：
>	求和=求和+当前元素
>返回求和的值
# 3.时间复杂度
线性枚举的时间复杂度为O(nm),其中n是线性表的长度。m是每次操作的量级，对于求最大值和求和来说，因为操作比较简单，所以为1，则整体的时间复杂度是O(n)的。这是因为线性枚举需要遍历列表中的每个元素。在处理大规模数据时，可能需要使用更高效的算法来提高搜索速度。
# 4.优缺点
## 4.1优点
线性枚举是一种简单直观的算法，容易理解和实现，也是暴力算法中最简单的一种。
## 4.2 缺点
线性枚举的时间复杂度较高，对于大规模数据集可能效率较低。
# 5.线性枚举的优化
## 5.1二分查找
如果线性表已排序，可以通过二分查找来提高效率。
## 5.2哈希表
可以使用哈希表来存储已经搜索过的元素，避免重复搜索。
## 5.3前缀和
可以存储前ⅰ个元素的和，避免重复计算。
## 5.4双指针
可以从两头开始搜索，提升搜索效率。

# 6.结论
线性枚举是一种简单而有效的算法思想，它可以用于解决许多基本的算法问题。虽然它的时间复杂度较高，但在处理小型数据集时仍然是一种常用的算法。在实际应用中，我们可以根据具体情况选择是否使用线性枚举，或者使用其他更高效的算法来提高程序的效率。

# 7.实战
## 7.1力扣1550. 存在连续三个奇数的数组
给你一个整数数组 `arr`，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 `true` ；否则，返回 `false` 
。
```c
bool threeConsecutiveOdds(int* arr, int arrSize) {
    for(int i = 0; i + 2 < arrSize ; i++){
        int a = arr[i];
        int b = arr[i+1];
        int c = arr[i+2];
        if(a % 2 == 1 && b % 2== 1 && c % 2 == 1){
            return true;
        }
    }
    return false;
}
```

## 7.2力扣485.最大连续1的个数
给定一个二进制数组 `nums` ， 计算其中最大连续 `1` 的个数。
```c
int findMaxConsecutiveOnes(int* nums, int numsSize) {
    int pre = 0;
    int max = 0;
    for(int i = 0; i < numsSize ; i++){
        if(nums[i] == 1){
            pre++;
            if(pre > max){
                max = pre;
            }
        }
        else{
            pre = 0;
        }
    }
    return max;
}
```
## 7.3力扣540 有序数组中的单一整数
给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。
请你找出并返回只出现一次的那个数。
你设计的解决方案必须满足 `O(log n)` 时间复杂度和 `O(1)` 空间复杂度。
```c
int singleNonDuplicate(int* nums, int numsSize) {
    if(numsSize == 1){
        return nums[0];
    }
    for(int i = 1; i < numsSize - 1; i++){
        if(nums[i] != nums[i+1] && nums[i] != nums[i-1]){
            return nums[i];
        }
    }
    if(nums[0] != nums[1]){
        return nums[0];
    }
    return nums[numsSize - 1];
}
```