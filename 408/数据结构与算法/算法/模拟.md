@[toc]
模拟算法其实就是根据题目做，题目要求什么，就做什么。一些复杂的模拟题其实还是把些简单的操作组合了一下，所以模拟题是最锻炼耐心的，也是训练编码能力的最好的暴力算法。
# 1.数据结构
对于模拟题而言，最关键的其实是数据结构，看到一个问题，选择合适的数据结构，
然后根据问题来实现对应的功能。模拟题的常见数据结构主要就是:数组、字符串、矩阵、链表、二叉树等。
## 1.1基于数组
利用数组的数据结构，根据题目要求，去实现算法，如:1920.基于排列构建数组、序创建目标数组、1603.设计停车系统、2149.按符号重排数组、2221.数组的三角和。
## 1.2 基于字符串
字符串配对数目、LCP 17.速算机器人、537.复数乘法利用字符串的数据结构，根据题目要求，去实现算法，如:2011.执行操作后的变量值。
## 1.3基于链表
利用链表的数据结构，根据题目要求，去实现算法，如:2181.合并零之间的节点、1823.找出游戏。
## 1.4基于矩阵
利用矩阵的数据结构，根据题目要求，去实现算法，如:2120.执行所有后指令、1252.奇数值单元格的数目、832.翻转图像、657.机器人能否返回原点、289.生命游戏、59.螺旋矩阵Ⅱ、885.螺旋矩阵 。
# 2.算法技巧
模拟时一般会用到一些算法技巧，或者说混合算法，比如 排序、递归、迭代 等等
## 2.1、排序
排序后，干一件事情，如:950.按递增顺序显示卡牌
## 2.2、递归
需要借助递归来实现，如:1688.比赛中的配对次数、169.得到 0的操作数、258.各位相加
## 2.3、迭代
不断迭代求解，其实就是利用 while 循环来实现功能，如:1860.增长的内存泄露、258.各位相加

# 3.实战
## 3.1 力扣面试题16.01 交换数字
编写一个函数，不用临时变量，直接交换`numbers = [a, b]`中`a`与`b`的值。
```c
int* swapNumbers(int* a, int numbersSize, int* returnSize){
    *returnSize = 2;
    a[0] = a[0] ^ a[1];
    a[1] = a[0] ^ a[1];
    a[0] = a[0] ^ a[1];
    return a;
}
```
## 3.2力扣  LCR 133.位1的个数
编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数。
```c
int hammingWeight(uint32_t n) {  
    int sum = 0;  
    while(n){  
        sum += n % 2;  
        n /= 2;  
    }   
return sum;  
}
```
## 3.3 力扣1991.找到数组的中间位置
给你一个下标从 **0** 开始的整数数组 `nums` ，请你找到 **最左边** 的中间位置 `middleIndex` （也就是所有可能中间位置下标最小的一个）。
```c
int findMiddleIndex(int* nums, int numsSize) {  
    for(int i = 0; i < numsSize; i++){  
        int l = 0;  
        int r = 0;  
        for(int j = 0; j < i; j++){  
            l += nums[j];  
        }  
        for(int j = i + 1; j < numsSize; j++){  
            r += nums[j];  
        }  
        if(l == r){  
            return i;  
        }       
}  
    return -1;  
}
```

