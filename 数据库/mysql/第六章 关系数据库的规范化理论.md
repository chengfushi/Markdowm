[toc]

# 1.问题的提出
## 1.1概念回顾

| 概念       | 描述                                   |
| -------- | ------------------------------------ |
| 关系       | 从形式上看，是二维表，是笛卡儿积的子集。                 |
| 关系模式     | 对关系的定义，型。                            |
| 关系数据库    | 从形式上看，由一组关系组成。                       |
| 关系数据库的模式 | 关系模式的全体。                             |

## 1.2.关系模式的形式化定义
关系模式由五部分组成，即它是一个五元组:
R(U, D, DOM, F)

| 组成部分 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| R        | 关系名                                                       |
| U        | 组成该关系的属性名集合                                       |
| D        | 属性组U中属性所来自的域                                       |
| DOM      | 属性向域的映象集合                                           |
| F        | 属性间数据的依赖关系集合                                     |
## 1.3.什么是数据依赖
数据依赖（Data Dependency）是数据库理论中的一个概念，它描述了数据库中数据之间的一种约束关系。数据依赖确保了数据库中数据的一致性和完整性。在关系数据库中，数据依赖主要分为以下几种类型：

1. **函数依赖（Functional Dependency, FD）**：这是最常见的数据依赖类型。如果对于关系中的每一个元组（行），属性集X的值能够唯一确定属性集Y的值，那么我们说Y函数依赖于X，记作X → Y。函数依赖是定义关系模式中主键和外键的基础。

2. **多值依赖（Multivalued Dependency, MVD）**：如果对于关系中的每一个元组，属性集X的值能够唯一确定属性集Y的所有可能值的集合，那么我们说Y多值依赖于X，记作X →→ Y。多值依赖通常用于处理更复杂的数据完整性约束。

3. **连接依赖（Join Dependency, JD）**：在关系数据库中，如果一个关系可以通过自然连接（natural join）操作从两个或多个更小的关系中重建出来，那么这些更小的关系之间存在连接依赖。

4. **超键依赖（Superkey Dependency）**：如果一个属性集能够唯一标识关系中的每一个元组，那么这个属性集被称为超键。超键依赖是指超键与其所标识的元组之间的关系。

5. **候选键依赖（Candidate Key Dependency）**：候选键是最小的超键，即没有冗余属性的超键。候选键依赖是指候选键与其所标识的元组之间的关系。

数据依赖在数据库设计中非常重要，因为它们帮助设计者理解和定义数据之间的逻辑关系，从而确保数据库的规范化，减少数据冗余，提高数据的一致性和完整性。
## 1.4.数据依赖对关系模式的影响
数据依赖在关系模式中的作用可以简要概括为以下几点：

1. **规范化指导**：帮助数据库设计者通过规范化过程减少数据冗余和避免更新异常。
2. **主键和外键确定**：通过函数依赖识别关系中的唯一标识符（主键）和跨关系连接的键（键）。
3. **维护数据完整性**：确保数据的一致性，防止插入、删除或更新操作导致的数据不一致。
4. **减少数据冗余**：通过识别和消除不必要的数据重复，提高存储效率。
5. **查询优化**：数据库系统利用数据依赖来优化查询执行计划，提高查询效率。
6. **数据库设计**：在设计阶段，数据依赖用于定义关系的结构和属性之间的逻辑关系。
7. **增强数据模型表达**：提供一种方式来精确描述数据的结构和行为，增强数据模型的表达能力。
8. **提高可维护性**：清晰的数据依赖关系有助于数据库的长期维护和升级。

# 2.规范化
规范化理论正是用来改造关系模式，通过分解关系模式来消除其中不合适的数据依赖，以解决插入异常、删除异常、更新异常和数据冗余问题。
## 2.1函数依赖

1. **平凡函数依赖（Trivial Functional Dependency）**：
   - 定义：当一个属性集Y包含在X中时，X对Y的函数依赖称为平凡函数依赖。
   - 例子：假设关系模式R(A, B, C)中，A是主键，那么A → B 和 A → C 都是平凡函数依赖，因为B和C都是由A隐含确定的。
   - 
1. **非平凡函数依赖（Non-trivial Functional Dependency）**：
   - 定义：如果属性集Y不包含在X中，且X对Y的函数依赖不是平凡函数依赖，那么这种依赖称为非平凡函数依赖。
   - 例子：在学生选课关系模式SC(S#, C#, Grade)中，如果S#（学生编号）和C#（课程编号）共同唯一确定Grade（成绩），则S#, C# → Grade 是一个非平凡函数依赖。

2. **完全函数依赖（Full Functional Dependency）**：
   - 定义：如果属性集X对属性集Y的函数依赖中，Y中的任何一个属性都不能由X的真子集决定，那么称Y对X是完全函数依赖的。
   - 例子：在关系模式R(A, B, C)中，如果A → B, C 且没有B → C 或 A → C，那么C对A是完全函数依赖的。

3. **部分函数依赖（Partial Functional Dependency）**：
   - 定义：如果属性集X对属性集Y的函数依赖中，Y可以由X的某个真子集决定，那么称Y对X是部分函数依赖的。
   - 例子：在关系模式R(A, B, C)中，如果A, B → C 且 B → C，那么C对A, B是部分函数依赖的，因为C可以由B单独决定。

4. **传递函数依赖（Transitive Functional Dependency）**：
   - 定义：如果属性集X决定属性集Y，并且Y又决定属性集Z，那么称Z对X是传递函数依赖的。
   - 例子：在关系模式R(A, B, C, D)中，如果A → B, B → C, C → D，那么D对A是传递函数依赖的，因为D的值可以通过A的值间接确定。
## 2.2码

| 候选码  | 能够唯一标识关系中每个元组的属性集合。                  |
| ---- | ------------------------------------ |
| 主码   | 被选作元组标识的候选码。                         |
| 主属性  | 包含在任何一个候选码中的属性。                      |
| 非主属性 | 不包含在任何一个候选码中的属性。                     |
| 外码   | 一个表中的属性集合，它与另一个表的主码相对应，用于建立两个表之间的关系。 |
## 2.3.范式(Normal-Form)
范式是符合某一种级别的关系模式的集合
关系数据库中的关系必须满足一定的要求。满足不同程度要求的为不同范式
范式的种类:
1. 第一范式(1NF)
2. 第二范式(2NF)
3. 第三范式(3NF)
4. BC范式(BCNF)
5. 第四范式(4NF)
6. 第五范式(5NF)
一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化。


1. **第一范式（1NF）**：
   - 要求：关系数据库的表中的每个字段都是不可分割的基本数据项，即每个字段都不可再分。
   - 目的：确保每列的原子性，即每个字段都只包含一个值，没有重复的组或列表。
   - **人话:大表中不能有小表。**

2. **第二范式（2NF）**：
   - 要求：在满足1NF的基础上，非主属性完全依赖于主键，而不是部分依赖于主键。
   - 目的：消除部分函数依赖，进一步减少数据冗余。

3. **第三范式（3NF）**：
   - 要求：在满足2NF的基础上，非主属性不传递依赖于主键，即非主属性只能直接依赖于主键，不能依赖于其他非主属性。
   - 目的：消除传递函数依赖，确保数据的依赖只与主键有关。

4. **BC范式（BCNF）**：
   - 要求：在满足3NF的基础上，对于任何非平凡的函数依赖X → Y，X都必须是超键。
   - 目的：消除主属性之间的函数依赖，确保更高层次的数据完整性。
   - 等价于:每一个决定属性因素都包含码
   - **人话:函数的左侧都必须包含码**


1NF

消除非主属性对码的部分函数依赖

2NF
消除非主属性对码的传递函数依赖

3NF

消除主属性对码的部分和传递函数依赖

BCNF

消除非平凡且非函数依赖的多值依赖

4NF

# 3.数据依赖的公理系统
逻辑蕴含
对于满足一组函数依赖F的关系模式R<U，F>，其任何一个关系，若函数依赖X→Y都成立，(即r中任意两元组t，s，若tX]=sX]，则tY]=s/Y])，则称F逻辑蕴含X→Y。
## 3.1ArmStrong公理系统
关系模式R<U，F>来说有以下的推理规则:
1. **自反律 (Reflexivity)**：如果集合Y是集合X的子集，并且集合X又是集合U的子集，那么可以推出集合X与集合Y之间存在某种关系，这种关系被集合F所包含。

2. **增广律 (Augmentation)**：如果集合X与集合Y之间的关系被集合F所包含，并且集合Z是集合U的子集，那么集合X与Z的并集与集合Y与Z的并集之间的关系也被集合F所包含。

3. **传递律 (Transitivity)**：如果集合X与集合Y之间的关系以及集合Y与集合Z之间的关系都被集合F所包含，那么可以推出集合X与集合Z之间也存在同样的关系，这种关系同样被集合F所包含。

## 3.2闭包
定义 设F为属性集U上的一组函数依赖，X≤ U，X*={A|X→A能由F根据Armstrong公理导出}，**X*称为属性集X关于函数依赖集F的闭包**
说人话:属**性x的闭包就是由属性x直接或间接推导出的所有属性的集合**

## 3.3计算关系R的属性集X的闭包的步骤如下

第一步:设最终将成为闭包的属性集是Y，把Y初始化为X;
第二步:检查F中的每一个函数依赖A→B，如果属性集A中所有属性均在Y中，而B中有的属性不在Y中，则将其加入到Y中:
第三步:重复第二步，直到没有属性可以添加到属性集Y中为止，最后得到的Y就是X+

## 3.4候选码求解理论与算法
对于给定的关系R(A1，A2，….An)和函数依赖集F，可将其属生分为4类:
- L类 仅出现在函数依赖左部的属性。
- R 类 仅出现在函数依赖右部的属性。
- N类在函数依赖左右两边均未出现的属性
- LR类 在函数依赖左右两边均出现的属性

定理：
1. 只在右边出现的属性，不属于候选码:
2. 只在左边出现的属性，一定存在于某候选码当中:
3. 左右都不出现的属性一定存在于任何候选码当中
4. 左右都出现的属性逐个与2,3的属性组合，求属性闭包，若闭包等于U,则为候选码。

**候选码求解步骤**
(1)将R的所有属性分为L、R、N、LR四类，令X代表L、N两类，Y代表LR类。
(2)求X+(X的闭包):若X+包含了R的全部属性，则X即为R的惟一候选码，转(5);否则转(3)
(3)在Y中逐一取每个属性A，求(XA)+。若它包含了R的全部属性，则转(5);否则调换一属性反复进行这一过程，直到试完所有Y中的属性。
(4)在Y中依次取二个、三个属性..求它们的属性闭包直到其闭包包含R的全部属性。
(5)输出结果。

# 4.最小函数依赖
最小函数依赖集是数据库理论中的一个重要概念，它用于描述表中不同属性间的依赖关系，并帮助优化数据库设计，减少数据冗余。以下是最小函数依赖集的定义和求解方法：

## 4.1最小函数依赖集的定义
如果函数依赖集F满足以下条件，则称F为最小函数依赖集或最小覆盖：
1. F中任一函数依赖的右部仅含有一个属性。
2. F中不存在这样的函数依赖X→A，使得F与F-{X→A}等价。
3. F中不存在这样的函数依赖X→A，X有真子集Z使得F-{X→A}∪{Z→A}与F等价。

## 4.2求解最小函数依赖集的方法
求解最小函数依赖集通常遵循以下步骤：
1. **右部最小化**：将函数依赖集中右部不为单个属性的依赖分解为单属性。
2. **消除冗余依赖**：对于每个函数依赖X→A，如果从函数依赖集中删除X→A后，所得的函数依赖集与原函数依赖集等价，则该函数依赖是多余的，可以删除。
3. **左部最小化**：对于左部不为单个属性的函数依赖AB→Y，如果删除A或B后，所得的函数依赖集与原函数依赖集等价，则A或B是多余的，可以删除。

通过这些步骤，我们可以从原始的函数依赖集中得到一个最小函数依赖集，这个集合中的函数依赖是不可约的，即不能再进一步简化，同时它们能够完全描述原始函数依赖集中的依赖关系。这个过程有助于我们更好地理解和设计数据库模式，确保数据的完整性和一致性。

# 5.无损连接
无损连接（Lossless Join）是数据库规范化理论中的一个概念，它指的是在对关系模式进行分解后，能够通过自然连接操作还原出原始关系模式的过程。具体来说，无损连接保证了在分解和合并过程中，数据的完整性和一致性得到保持，既不丢失信息，也不增加额外的信息。

## 5.1什么是无损连接？
无损连接是指在对关系模式进行分解后，通过自然连接操作能够无损失地还原出原始关系模式。这意味着分解后的关系模式通过自然连接得到的结果是唯一的，并且与原始关系模式等价，没有丢失任何信息。

## 5.2如何检验无损连接？
检验无损连接通常有两种方法：

1. **无损连接定理**：对于关系模式R(U, F)的一个分解ρ={R1<U1,F1>,R2<U2,F2>,...,Rk<Uk,Fk>}，如果对于任意两个关系模式Ri和Rj，它们的属性集交集U1∩U2能够函数决定U1-U2或者U2-U1（即U1∩U2→U1-U2∈F+ 或 U1∩U2→U2-U1∈F+），则该分解是无损连接的。

2. **算法方法（Chase算法）**：
   - 建立一个初始的二维表，表中每一列对应一个属性，每一行对应分解中的一个关系模式。如果属性Aj属于Ui，则在j列i行上填上aj，否则填上bij。
   - 对于函数依赖集F中的每一个函数依赖FDi，找到Xi所对应的列中具有相同符号的那些行。考察这些行中j列的元素，若其中有aj，则全部改为aj，否则全部改为bij，i是这些行的行号最小值。
   - 如果在某次更改后，有一行变成全部为a（即a1,a2,...,an），则算法终止，且分解ρ具有无损连接性；否则不具有无损连接性。
   - 对F中所有函数依赖逐一进行这样的处理，称为对F的一次扫描。比较扫描前后表有无变化，如有变化，则返回第二步，否则算法终止。如果发生循环，那么前次扫描至少应使该表减少一个符号，表中符号有限，因此循环必然终止。

通过上述方法，可以检验一个关系模式的分解是否是无损连接的，从而确保数据库分解后的数据完整性和一致性。

